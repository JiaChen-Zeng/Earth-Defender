# Naming Convention:
# - <var>: normal variable
# - <_var>: variable for memory address pointer
# - <Class_property>: property offset for Class

include "lib/core.snb"
include "games/utils.snb"
include "games/Tower.snb"
include "games/Bullet.snb"
include "games/Enemy.snb"
include "games/Path.snb"
include "memory.snb"

setManualFlush(true)

const STATE_INITIAL -> 0
const STATE_READY -> 1
const STATE_BATTLE -> 2
const STATE_GAMEOVER -> 3

const GOLD_INITIAL -> 10
const GOLD_MAX -> 50

# light -> dark
# blue -> green -> orange -> red -> purple
memory[_colors] -> rgb(100, 145, 217)
memory[_colors + 1] -> rgb(112, 224, 161)
memory[_colors + 2] -> rgb(227, 189, 107)
memory[_colors + 3] -> rgb(235, 131, 117)
memory[_colors + 4] -> rgb(235, 113, 224)
memory[_colors + 5] -> rgb(15, 82, 189)
memory[_colors + 6] -> rgb(30, 148, 81)
memory[_colors + 7] -> rgb(191, 136, 17)
memory[_colors + 8] -> rgb(168, 42, 25)
memory[_colors + 9] -> rgb(173, 14, 159)

main()

def main()
	enterInitial()
	while true
		update()
		draw()
		debug(0 < memory[_gold])
		flush()

def update()
	if memory[_state] = STATE_INITIAL
		if keyPressed(KEY_ENTER)
			enterReady()

	if memory[_state] = STATE_READY
		if keyPressed(KEY_LEFT)
			memory[_selectedTowerIndex] -> max(memory[_selectedTowerIndex] - 1, 0)
		if keyPressed(KEY_RIGHT)
			memory[_selectedTowerIndex] -> min(memory[_selectedTowerIndex] + 1, LANE_COUNT - 1)
		if and(keyPressed(KEY_SPACE), 0 < memory[_gold])
			_towerLevel -> Array_at(_towers, memory[_selectedTowerIndex]) + Tower_level
			if (memory[_towerLevel] + 1) <= TOWER_LEVEL_MAX
				memory[_gold] -> memory[_gold] - 1
				memory[_towerLevel] -> memory[_towerLevel] + 1

		if keyPressed(KEY_ENTER)
			enterBattle()

	if memory[_state] = STATE_BATTLE
		updateTowers()
		updateBullets()
		updateEnemies()
		handleEnemiesEnemiesCollision()
		handleEnemiesTowersCollision()
		handleEnemiesBulletsCollision()
		if anyEnemyExists() = false
			enterReady()

def updateEnemies()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			Enemy_update(_enemy)
		i -> i + 1

def updateTowers()
	i -> 0
	while i < memory[_towers + Array_length]
		_tower -> Array_at(_towers, i)
		if 0 < memory[_tower + Tower_level]
			Tower_update(_tower)
		i -> i + 1

def updateBullets()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			Bullet_update(_bullet)
		i -> i + 1

def handleEnemiesEnemiesCollision()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			handleEnemyEnemiesCollision(_enemy, i)
		i -> i + 1

def handleEnemyEnemiesCollision(_enemy, index)
	speedBuff -> 0
	i -> 0
	while i < memory[_enemies + Array_length]
		if i != index
			_otherEnemy -> Array_at(_enemies, i)
			if and(0 < memory[_otherEnemy + Enemy_life], Enemy_collidedWithEnemy(_enemy, _otherEnemy))
				speedBuff -> speedBuff + 1
		i -> i + 1
	Enemy_setSpeedBuff(_enemy, speedBuff)

def handleEnemiesTowersCollision()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			if Enemy_collidedWithTower(_enemy)
				onEnemyCollidedWithTower(_enemy)

		if Enemy_arrived(_enemy)
			enemyExplode(_enemy)
		i -> i + 1

def handleEnemiesBulletsCollision()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			handleEnemiesBulletCollision(_bullet)
		i -> i + 1

def handleEnemiesBulletCollision(_bullet)
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if and(0 < memory[_enemy + Enemy_life], Enemy_collidedWithBullet(_enemy, _bullet))
			Enemy_hit(_enemy)
			Bullet_remove(_bullet)
		i -> i + 1

def enterInitial()
	memory[_state] -> STATE_INITIAL
	memory[_gold] -> GOLD_INITIAL
	memory[_enemyCount] -> 3
	initTowers()

def enterReady()
	memory[_state] -> STATE_READY
	memory[_selectedTowerIndex] -> 0
	memory[_enemyCount] -> min(memory[_enemyCount] + 1, LANE_COUNT)
	initPaths()

def enterBattle()
	memory[_state] -> STATE_BATTLE
	initBullets()
	initEnemies()

def draw()
	clear()
	drawTowers()
	if memory[_state] = STATE_INITIAL

	if memory[_state] = STATE_READY
		drawTowerSelector()
		drawPaths()

	if memory[_state] = STATE_BATTLE
		drawPaths()
		drawEnemies()
		drawBullets()

	drawUI()

def drawUI()
	drawGoldBar()

const GOLD_BAR_X -> SCREEN_WIDTH - 8
const GOLD_BAR_Y -> 30
const GOLD_BAR_WIDTH -> 7
const GOLD_BAR_HEIGHT -> 37
const GOLD_BAR_COLOR -> 938824 # rgb(217, 206, 56)
def drawGoldBar()
	drawRectOutline(GOLD_BAR_X, GOLD_BAR_Y, GOLD_BAR_WIDTH, GOLD_BAR_HEIGHT, GOLD_BAR_COLOR)
	i -> 0
	while i < GOLD_INDICATOR_COUNT
		drawGoldIndicator(i)
		i -> i + 1

const GOLD_INDICATOR_COUNT -> 5
const GOLD_INDICATOR_WIDTH -> GOLD_BAR_WIDTH - 1
const GOLD_INDICATOR_HEIGHT -> 6
const GOLD_INDICATOR_X -> GOLD_BAR_X + 1
const GOLD_INDICATOR_Y -> GOLD_BAR_Y + GOLD_BAR_HEIGHT - GOLD_INDICATOR_HEIGHT - 1
const GOLD_INDICATOR_SPACE -> 1
def drawGoldIndicator(index) # index increase from bottom to top
	level -> (memory[_gold] / GOLD_INDICATOR_COUNT) - 1 + (mod(memory[_gold], GOLD_INDICATOR_COUNT) > index)
	if -1 < level
		drawRect(GOLD_INDICATOR_X, GOLD_INDICATOR_Y - ((GOLD_INDICATOR_SPACE + GOLD_INDICATOR_HEIGHT) * index), GOLD_INDICATOR_WIDTH, GOLD_INDICATOR_HEIGHT, memory[_colors + level])

def drawTowers()
	i -> 0
	while i < memory[_towers + Array_length]
		Tower_draw(Array_at(_towers, i))
		i -> i + 1

const TOWER_SELECTOR_Y -> SCREEN_HEIGHT - 20
const TOWER_SELECTOR_RADIUS -> 3
def drawTowerSelector()
	drawCircle(getLaneMiddleX(memory[_selectedTowerIndex]), TOWER_SELECTOR_Y, TOWER_SELECTOR_RADIUS, 777777)

def drawPaths()
	i -> 0
	while i < memory[_paths + Array_length]
		Path_draw(Array_at(_paths, i))
		i -> i + 1

def drawEnemies()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			Enemy_draw(_enemy)
		i -> i + 1

def drawBullets()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			Bullet_draw(_bullet)
		i -> i + 1

def initTowers()
	Array(_towers, LANE_COUNT, Tower_size)
	i -> 0
	while i < LANE_COUNT
		Tower(Array_at(_towers, i), i, 1)
		i -> i + 1

const BULLET_MAX_COUNT -> 2000
def initBullets()
	Array(_bullets, BULLET_MAX_COUNT, Bullet_size)
	memory[_bulletNextIndex] -> 0

def initPaths()
	assertEx(memory[_enemyCount] <= LANE_COUNT, ERROR_ENEMY_COUNT_EXCEEDED)
	Array(_paths, memory[_enemyCount], Path_size)

	setMemory(_tempArray, memory[_paths + Array_length], false) # true for existence of path in <index>-nd lane
	i -> 0
	while i < memory[_paths + Array_length]
		newPathSet -> false
		while newPathSet = false
			laneIndex -> random(LANE_COUNT)
			if memory[_tempArray + laneIndex] = false
				memory[_tempArray + laneIndex] -> true
				Path(Array_at(_paths, i), laneIndex, random(LANE_COUNT), 0, 2 + random(SPOT_RANGE))
				newPathSet -> true
		i -> i + 1

def initEnemies()
	Array(_enemies, memory[_enemyCount], Enemy_size)
	i -> 0
	while i < memory[_enemies + Array_length]
		Enemy(Array_at(_enemies, i), 1, Array_at(_paths, i))
		i -> i + 1

def enemyExplode(_enemy)
	memory[_enemy + Enemy_life] -> 0
	lane -> Enemy_getToLane(_enemy) - 1
	i -> 0
	while i < 3
		if and(0 <= lane, lane < LANE_COUNT)
			Tower_hit(Array_at(_towers, lane))
		lane -> lane + 1
		i -> i + 1

def anyTowerExists()
	towerExists -> false
	i -> 0
	while i < memory[_towers + Array_length]
		towerExists -> or(towerExists, 0 < memory[Array_at(_towers, i) + Tower_level])
		i -> i + 1
	out -> towerExists

def anyEnemyExists()
	enemyExists -> false
	i -> 0
	while i < memory[_enemies + Array_length]
		enemyExists -> or(enemyExists, 0 < memory[Array_at(_enemies, i) + Enemy_life])
		i -> i + 1
	out -> enemyExists

def onTowerShoot(index)
	Bullet(Array_at(_bullets, memory[_bulletNextIndex]), index)
	memory[_bulletNextIndex] -> memory[_bulletNextIndex] + 1

def onTowerDestroyed(index)

def onEnemyKilled(_enemy)
	memory[_gold] -> min(memory[_gold] + 1, GOLD_MAX)

def onEnemyCollidedWithTower(_enemy)
	_tower -> Array_at(_towers, Enemy_getToLane(_enemy))
	towerExists -> 0 < memory[_tower + Tower_level]
	if towerExists
		memory[_enemy + Enemy_life] -> 0
		Tower_hit(_tower)