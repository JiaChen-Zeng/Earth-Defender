# Naming Convention:
# - <var>: normal variable
# - <_var>: variable for memory address pointer
# - <Class_property>: property offset for Class

include "lib/core.snb"
include "games/utils.snb"
include "games/sound.snb"
include "games/Tower.snb"
include "games/Bullet.snb"
include "games/Enemy.snb"
include "games/Path.snb"
include "memory.snb"

setManualFlush(true)

const STATE_INITIAL -> 0
const STATE_READY -> 1
const STATE_BATTLE -> 2
const STATE_GAMEOVER -> 3

const GOLD_INITIAL -> 5
const GOLD_MAX -> 50

const ENEMY_LIFE_TOTAL_INITIAL -> -10
const ENEMY_LIFE_TOTAL_INCREMENT -> 25
const ENEMY_LIFE_TOTAL_MAX -> 50 * 7

# light -> dark
# blue -> green -> orange -> red -> purple
memory[_colors] -> rgb(100, 145, 217)
memory[_colors + 1] -> rgb(112, 224, 161)
memory[_colors + 2] -> rgb(227, 189, 107)
memory[_colors + 3] -> rgb(235, 131, 117)
memory[_colors + 4] -> rgb(235, 113, 224)
memory[_colors + 5] -> rgb(15, 82, 189)
memory[_colors + 6] -> rgb(30, 148, 81)
memory[_colors + 7] -> rgb(191, 136, 17)
memory[_colors + 8] -> rgb(168, 42, 25)
memory[_colors + 9] -> rgb(173, 14, 159)

main()

def main()
	enterInitial()
	while true
		update()
		draw()
		flush()

def update()
	if memory[_state] = STATE_INITIAL
		if keyPressed(KEY_SPACE)
			enterReady()
			playGameStartSound()

	if memory[_state] = STATE_READY
		if keyPressed(KEY_LEFT)
			memory[_selectedTowerIndex] -> max(memory[_selectedTowerIndex] - 1, 0)
		if keyPressed(KEY_RIGHT)
			memory[_selectedTowerIndex] -> min(memory[_selectedTowerIndex] + 1, LANE_COUNT - 1)

		if keyPressed(KEY_UP)
			goldEnough -> 0 < memory[_gold]
			if goldEnough
				canLevelUp -> Tower_addLevel(Array_at(_towers, memory[_selectedTowerIndex]), 1)
				if canLevelUp
					memory[_gold] -> memory[_gold] - 1
					playActionSound()
				if canLevelUp = false
					playInvalidActionSound()
			if goldEnough = false
				playInvalidActionSound()
		if keyPressed(KEY_DOWN)
			canLevelDown -> Tower_addLevel(Array_at(_towers, memory[_selectedTowerIndex]), -1)
			if canLevelDown
				memory[_gold] -> memory[_gold] + 1
				playActionSound()
			if canLevelDown = false
				playInvalidActionSound()

		if keyPressed(KEY_SPACE)
			exists -> anyTowerExists()
			if exists
				enterBattle()
			if exists = false
				playInvalidActionSound()

	if memory[_state] = STATE_BATTLE
		updateTowers()
		updateBullets()
		updateEnemies()
		handleEnemiesEnemiesCollision()
		handleEnemiesTowersCollision()
		handleEnemiesBulletsCollision()
		if anyEnemyExists() = false
			if memory[_enemyLifeTotal] = ENEMY_LIFE_TOTAL_MAX
				throwError(ERROR_NOT_IMPLEMENTED)
			if memory[_enemyLifeTotal] != ENEMY_LIFE_TOTAL_MAX
				enterReady()

def updateEnemies()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			Enemy_update(_enemy)
		i -> i + 1

def updateTowers()
	i -> 0
	while i < memory[_towers + Array_length]
		_tower -> Array_at(_towers, i)
		if 0 < memory[_tower + Tower_level]
			Tower_update(_tower)
		i -> i + 1

def updateBullets()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			Bullet_update(_bullet)
		i -> i + 1

def handleEnemiesEnemiesCollision()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			handleEnemyEnemiesCollision(_enemy, i)
		i -> i + 1

def handleEnemyEnemiesCollision(_enemy, index)
	speedBuff -> 0
	i -> 0
	while i < memory[_enemies + Array_length]
		if i != index
			_otherEnemy -> Array_at(_enemies, i)
			if and(0 < memory[_otherEnemy + Enemy_life], Enemy_collidedWithEnemy(_enemy, _otherEnemy))
				speedBuff -> speedBuff + 1
		i -> i + 1
	Enemy_setSpeedBuff(_enemy, speedBuff)

def handleEnemiesTowersCollision()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			if Enemy_collidedWithTower(_enemy)
				onEnemyCollidedWithTower(_enemy)
			if Enemy_arrived(_enemy)
				enemyExplode(_enemy)
		i -> i + 1

def handleEnemiesBulletsCollision()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			handleEnemiesBulletCollision(_bullet)
		i -> i + 1

def handleEnemiesBulletCollision(_bullet)
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if and(0 < memory[_enemy + Enemy_life], Enemy_collidedWithBullet(_enemy, _bullet))
			bulletExplode(_bullet)
		i -> i + 1

def enterInitial()
	memory[_state] -> STATE_INITIAL
	memory[_gold] -> GOLD_INITIAL
	memory[_enemyLifeTotal] -> ENEMY_LIFE_TOTAL_INITIAL
	initTowers()

def enterReady()
	memory[_state] -> STATE_READY
	memory[_selectedTowerIndex] -> 0
	memory[_enemyLifeTotal] -> min(memory[_enemyLifeTotal] + ENEMY_LIFE_TOTAL_INCREMENT, ENEMY_LIFE_TOTAL_MAX)
	initPathsAndEnemies()

def enterBattle()
	memory[_state] -> STATE_BATTLE
	initBullets()

def draw()
	clear()
	drawTowers()
	if memory[_state] = STATE_INITIAL

	if memory[_state] = STATE_READY
		drawTowerSelector()
		drawPaths()

	if memory[_state] = STATE_BATTLE
		drawPaths()
		drawEnemies()
		drawBullets()

	drawUI()

def drawUI()
	drawGoldBar()

const GOLD_BAR_X -> SCREEN_WIDTH - 8
const GOLD_BAR_Y -> 30
const GOLD_BAR_WIDTH -> 7
const GOLD_BAR_HEIGHT -> 37
const GOLD_BAR_COLOR -> 938824 # rgb(217, 206, 56)
def drawGoldBar()
	drawRectOutline(GOLD_BAR_X, GOLD_BAR_Y, GOLD_BAR_WIDTH, GOLD_BAR_HEIGHT, GOLD_BAR_COLOR)
	i -> 0
	while i < GOLD_INDICATOR_COUNT
		drawGoldIndicator(i)
		i -> i + 1

const GOLD_INDICATOR_COUNT -> 5
const GOLD_INDICATOR_WIDTH -> GOLD_BAR_WIDTH - 1
const GOLD_INDICATOR_HEIGHT -> 6
const GOLD_INDICATOR_X -> GOLD_BAR_X + 1
const GOLD_INDICATOR_Y -> GOLD_BAR_Y + GOLD_BAR_HEIGHT - GOLD_INDICATOR_HEIGHT - 1
const GOLD_INDICATOR_SPACE -> 1
def drawGoldIndicator(index) # index increase from bottom to top
	level -> (memory[_gold] / GOLD_INDICATOR_COUNT) - 1 + (mod(memory[_gold], GOLD_INDICATOR_COUNT) > index)
	if -1 < level
		drawRect(GOLD_INDICATOR_X, GOLD_INDICATOR_Y - ((GOLD_INDICATOR_SPACE + GOLD_INDICATOR_HEIGHT) * index), GOLD_INDICATOR_WIDTH, GOLD_INDICATOR_HEIGHT, memory[_colors + level])

def drawTowers()
	i -> 0
	while i < memory[_towers + Array_length]
		Tower_draw(Array_at(_towers, i))
		i -> i + 1

const TOWER_SELECTOR_Y -> SCREEN_HEIGHT - 20
const TOWER_SELECTOR_RADIUS -> 3
const TOWER_SELECTOR_COLOR -> 222222
def drawTowerSelector()
	x -> getLaneMiddleX(memory[_selectedTowerIndex])
	drawPixel(x, TOWER_SELECTOR_Y, TOWER_SELECTOR_COLOR)
	drawPixel(x, TOWER_SELECTOR_Y + 1, TOWER_SELECTOR_COLOR)
	drawPixel(x, TOWER_SELECTOR_Y + 2, TOWER_SELECTOR_COLOR)
	drawPixel(x, TOWER_SELECTOR_Y + 3, TOWER_SELECTOR_COLOR)
	drawPixel(x, TOWER_SELECTOR_Y + 4, TOWER_SELECTOR_COLOR)
	drawPixel(x - 1, TOWER_SELECTOR_Y + 3, TOWER_SELECTOR_COLOR)
	drawPixel(x + 1, TOWER_SELECTOR_Y + 3, TOWER_SELECTOR_COLOR)
	drawPixel(x - 2, TOWER_SELECTOR_Y + 2, TOWER_SELECTOR_COLOR)
	drawPixel(x + 2, TOWER_SELECTOR_Y + 2, TOWER_SELECTOR_COLOR)

def drawPaths()
	i -> 0
	while i < memory[_paths + Array_length]
		Path_draw(Array_at(_paths, i))
		i -> i + 1

def drawEnemies()
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if 0 < memory[_enemy + Enemy_life]
			Enemy_draw(_enemy)
		i -> i + 1

def drawBullets()
	i -> 0
	while i < memory[_bulletNextIndex]
		_bullet -> Array_at(_bullets, i)
		if Bullet_isLive(_bullet)
			Bullet_draw(_bullet)
		i -> i + 1

def initTowers()
	Array(_towers, LANE_COUNT, Tower_size)
	i -> 0
	while i < LANE_COUNT
		Tower(Array_at(_towers, i), i, 0)
		i -> i + 1

const BULLET_MAX_COUNT -> 2000
def initBullets()
	Array(_bullets, BULLET_MAX_COUNT, Bullet_size)
	memory[_bulletNextIndex] -> 0

def initPathsAndEnemies()
	life -> 5
	enemyCount -> memory[_enemyLifeTotal] / life
	smallEnemyLife -> remainder(memory[_enemyLifeTotal], life)
	while LANE_COUNT <= (enemyCount + (smallEnemyLife != 0))
		life -> life + 5
		enemyCount -> memory[_enemyLifeTotal] / life
		smallEnemyLife -> remainder(memory[_enemyLifeTotal], life)

	Array(_paths, enemyCount + (smallEnemyLife != 0), Path_size)

	setMemory(_tempArray, memory[_paths + Array_length], false) # true for existence of path in <index>-nd lane
	i -> 0
	while i < memory[_paths + Array_length]
		newPathSet -> false
		while newPathSet = false
			laneIndex -> random(LANE_COUNT)
			if memory[_tempArray + laneIndex] = false
				memory[_tempArray + laneIndex] -> true
				Path(Array_at(_paths, i), laneIndex, random(LANE_COUNT), 0, 2 + random(SPOT_RANGE))
				newPathSet -> true
		i -> i + 1

	Array(_enemies, memory[_paths + Array_length], Enemy_size)
	i -> 0
	while i < enemyCount
		Enemy(Array_at(_enemies, i), life, Array_at(_paths, i))
		i -> i + 1
	if smallEnemyLife != 0
		Enemy(Array_at(_enemies, i), smallEnemyLife, Array_at(_paths, i))

def bulletExplode(_bullet)
	i -> 0
	while i < memory[_enemies + Array_length]
		_enemy -> Array_at(_enemies, i)
		if and(0 < memory[_enemy + Enemy_life], Bullet_isEnemyInExplosion(_bullet, _enemy))
			Enemy_hit(_enemy)
		i -> i + 1
	Bullet_remove(_bullet)

def enemyExplode(_enemy)
	memory[_enemy + Enemy_life] -> 0
	lane -> Enemy_getToLane(_enemy) - 1
	i -> 0
	while i < 3
		if and(0 <= lane, lane < LANE_COUNT)
			_tower -> Array_at(_towers, lane)
			if 0 < memory[_tower + Tower_level]
				Tower_hit(_tower)
		lane -> lane + 1
		i -> i + 1

def anyTowerExists()
	towerExists -> false
	i -> 0
	while i < memory[_towers + Array_length]
		towerExists -> or(towerExists, 0 < memory[Array_at(_towers, i) + Tower_level])
		i -> i + 1
	out -> towerExists

def anyEnemyExists()
	enemyExists -> false
	i -> 0
	while i < memory[_enemies + Array_length]
		enemyExists -> or(enemyExists, 0 < memory[Array_at(_enemies, i) + Enemy_life])
		i -> i + 1
	out -> enemyExists

def onTowerShoot(index)
	Bullet(Array_at(_bullets, memory[_bulletNextIndex]), index)
	memory[_bulletNextIndex] -> memory[_bulletNextIndex] + 1

def onTowerDestroyed(index)

def onEnemyKilled(_enemy)
	memory[_gold] -> min(memory[_gold] + 1, GOLD_MAX)
	playGoldSound()

def onEnemyCollidedWithTower(_enemy)
	_tower -> Array_at(_towers, Enemy_getToLane(_enemy))
	towerExists -> 0 < memory[_tower + Tower_level]
	if towerExists
		memory[_enemy + Enemy_life] -> 0
		Tower_hit(_tower)